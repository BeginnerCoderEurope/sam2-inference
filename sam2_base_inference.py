# -*- coding: utf-8 -*-
"""Sam2-base-inference.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1niXsERBBbM1nU5bK9HgPHpJVYV2MlfE4
"""

import sys
print(sys.version)

!cat /proc/cpuinfo

using_colab = True
# https://github.com/facebookresearch/segment-anything-2/blob/main/notebooks/automatic_mask_generator_example.ipynb

if using_colab:
    import torch
    import torchvision
    print("PyTorch version:", torch.__version__)
    print("Torchvision version:", torchvision.__version__)
    print("CUDA is available:", torch.cuda.is_available())
    import sys
    !{sys.executable} -m pip install opencv-python matplotlib
    !{sys.executable} -m pip install 'git+https://github.com/facebookresearch/segment-anything-2.git'
    !{sys.executable} -m pip install"https://github.com/MedicineToken/Medical-SAM2.git"

    !mkdir -p images
    !wget -P images https://raw.githubusercontent.com/facebookresearch/segment-anything-2/main/notebooks/images/cars.jpg

    !mkdir -p ../checkpoints/
    !wget -P ../checkpoints/ https://dl.fbaipublicfiles.com/segment_anything_2/072824/sam2_hiera_large.pt

"""# Import Libraries and Dependencies

"""

import os
# if using Apple MPS, fall back to CPU for unsupported ops
os.environ["PYTORCH_ENABLE_MPS_FALLBACK"] = "1"
import numpy as np
import torch
import matplotlib.pyplot as plt
from PIL import Image

# select the device for computation
if torch.cuda.is_available():
    device = torch.device("cuda")
elif torch.backends.mps.is_available():
    device = torch.device("mps")
else:
    device = torch.device("cpu")
print(f"using device: {device}")

if device.type == "cuda":
    # use bfloat16 for the entire notebook
    torch.autocast("cuda", dtype=torch.bfloat16).__enter__()
    # turn on tfloat32 for Ampere GPUs (https://pytorch.org/docs/stable/notes/cuda.html#tensorfloat-32-tf32-on-ampere-devices)
    if torch.cuda.get_device_properties(0).major >= 8:
        torch.backends.cuda.matmul.allow_tf32 = True
        torch.backends.cudnn.allow_tf32 = True
elif device.type == "mps":
    print(
        "\nSupport for MPS devices is preliminary. SAM 2 is trained with CUDA and might "
        "give numerically different outputs and sometimes degraded performance on MPS. "
        "See e.g. https://github.com/pytorch/pytorch/issues/84936 for a discussion."
    )

np.random.seed(3)

def show_anns(anns, borders=True):
    if len(anns) == 0:
        return
    sorted_anns = sorted(anns, key=(lambda x: x['area']), reverse=True)
    ax = plt.gca()
    ax.set_autoscale_on(False)

    img = np.ones((sorted_anns[0]['segmentation'].shape[0], sorted_anns[0]['segmentation'].shape[1], 4))
    img[:, :, 3] = 0
    for ann in sorted_anns:
        m = ann['segmentation']
        color_mask = np.concatenate([np.random.random(3), [0.5]])
        img[m] = color_mask
        if borders:
            import cv2
            contours, _ = cv2.findContours(m.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
            # Try to smooth contours
            contours = [cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours]
            cv2.drawContours(img, contours, -1, (0, 0, 1, 0.4), thickness=1)

    ax.imshow(img)

#image = Image.open('images/cars.jpg')
#image = Image.open('images/1.bmp')
#image = Image.open('images/2.png')
image = Image.open('images/3.bmp')
image = np.array(image.convert("RGB"))

type(image)

plt.figure(figsize=(20, 20))
plt.imshow(image)
plt.axis('off')
plt.show()

"""#  Automatically generating object masks with SAM"""

from sam2.build_sam import build_sam2
from sam2.automatic_mask_generator import SAM2AutomaticMaskGenerator

sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
model_cfg = "sam2_hiera_l.yaml"
sam2 = build_sam2(model_cfg, sam2_checkpoint, device=device, apply_postprocessing=False)

mask_generator = SAM2AutomaticMaskGenerator(sam2)

masks = mask_generator.generate(image)

print(len(masks))
print(masks[0].keys())

plt.figure(figsize=(20, 20))
plt.imshow(image)
show_anns(masks)
plt.axis('on')
plt.show()

"""# Test Automatically generating object masks with SAM using kwargs"""

#Automatically generating object masks with SAM

from sam2.build_sam import build_sam2
from sam2.automatic_mask_generator import SAM2AutomaticMaskGenerator

sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
model_cfg = "sam2_hiera_l.yaml"
sam_kwargs = {
    "points_per_side": 64,
    "points_per_batch": 128,
    "pred_iou_thresh": 0.6,
    "stability_score_thresh": 0.8,
    "mask_threshold":   0.5,
    "crop_n_layers": 2,
    "crop_n_points_downscale_factor": 2,
    "min_mask_region_area": 100,
} #sam_kwargs test
sam2 = build_sam2(model_cfg, sam2_checkpoint, device=device, kwargs =sam_kwargs,apply_postprocessing=False) #sam kwargs test
#predictor_kwargs Not tested, but if you want to tune the predictor do it here  because SAM2AutomaticMaskGenerator uses SAM2ImagePredictor
#predictor = SAM2ImagePredictor(sam2,kwargs = predictor_kwargs)
mask_generator = SAM2AutomaticMaskGenerator(sam2)

"""# Documentation of kwargs

"""

#Arguments for sam_kwargs:
#           model (Sam): The SAM 2 model to use for mask prediction.
#           points_per_side (int or None): The number of points to be sampled
#             along one side of the image. The total number of points is
#             points_per_side**2. If None, 'point_grids' must provide explicit
#             point sampling.
#           points_per_batch (int): Sets the number of points run simultaneously
#             by the model. Higher numbers may be faster but use more GPU memory.
#           pred_iou_thresh (float): A filtering threshold in [0,1], using the
#             model's predicted mask quality.
#           stability_score_thresh (float): A filtering threshold in [0,1], using
#             the stability of the mask under changes to the cutoff used to binarize
#             the model's mask predictions.
#           stability_score_offset (float): The amount to shift the cutoff when
#             calculated the stability score.
#           mask_threshold (float): Threshold for binarizing the mask logits
#           box_nms_thresh (float): The box IoU cutoff used by non-maximal
#             suppression to filter duplicate masks.
#           crop_n_layers (int): If >0, mask prediction will be run again on
#             crops of the image. Sets the number of layers to run, where each
#             layer has 2**i_layer number of image crops.
#           crop_nms_thresh (float): The box IoU cutoff used by non-maximal
#             suppression to filter duplicate masks between different crops.
#           crop_overlap_ratio (float): Sets the degree to which crops overlap.
#             In the first crop layer, crops will overlap by this fraction of
#             the image length. Later layers with more crops scale down this overlap.
#           crop_n_points_downscale_factor (int): The number of points-per-side
#             sampled in layer n is scaled down by crop_n_points_downscale_factor**n.
#           point_grids (list(np.ndarray) or None): A list over explicit grids
#             of points used for sampling, normalized to [0,1]. The nth grid in the
#             list is used in the nth crop layer. Exclusive with points_per_side.
#           min_mask_region_area (int): If >0, postprocessing will be applied
#             to remove disconnected regions and holes in masks with area small_finetuneder
#             than min_mask_region_area. Requires opencv.
#           output_mode (str): The form masks are returned in. Can be 'binary_mask',
#             'uncompressed_rle', or 'coco_rle'. 'coco_rle' requires pycocotools.
#             For large resolutions, 'binary_mask' may consume large amounts of
#             memory.
#           use_m2m (bool): Whether to add a one step refinement using previous mask predictions.
#           multimask_output (bool): Whether to output multimask at each point of the grid.

#Arguments for predictor_kwargs:
          # sam_model (Sam-2): The model to use for mask prediction.
          # mask_threshold (float): The threshold to use when converting mask logits
          #   to binary masks. Masks are thresholded at 0 by default.
          # max_hole_area (int): If max_hole_area > 0, we fill small_finetuned holes in up to
          #   the maximum area of max_hole_area in low_res_masks.
          # max_sprinkle_area (int): If max_sprinkle_area > 0, we remove small_finetuned sprinkles up to
          #   the maximum area of max_sprinkle_area in low_res_masks.

"""# Image Predictor Utility Functions


"""

#Image Predictor

np.random.seed(3)

def show_mask(mask, ax, random_color=False, borders = True):
    if random_color:
        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)
    else:
        color = np.array([30/255, 144/255, 255/255, 0.6])
    h, w = mask.shape[-2:]
    mask = mask.astype(np.uint8)
    mask_image =  mask.reshape(h, w, 1) * color.reshape(1, 1, -1)
    if borders:
        import cv2
        contours, _ = cv2.findContours(mask,cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        # Try to smooth contours
        contours = [cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours]
        mask_image = cv2.drawContours(mask_image, contours, -1, (1, 1, 1, 0.5), thickness=2)
    ax.imshow(mask_image)

def show_points(coords, labels, ax, marker_size=375):
    pos_points = coords[labels==1]
    neg_points = coords[labels==0]
    ax.scatter(pos_points[:, 0], pos_points[:, 1], color='green', marker='*', s=marker_size, edgecolor='white', linewidth=1.25)
    ax.scatter(neg_points[:, 0], neg_points[:, 1], color='red', marker='*', s=marker_size, edgecolor='white', linewidth=1.25)

def show_box(box, ax):
    x0, y0 = box[0], box[1]
    w, h = box[2] - box[0], box[3] - box[1]
    ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0, 0, 0, 0), lw=2))

def show_masks(image, masks, scores, point_coords=None, box_coords=None, input_labels=None, borders=True):
    for i, (mask, score) in enumerate(zip(masks, scores)):
        plt.figure(figsize=(10, 10))
        plt.imshow(image)
        show_mask(mask, plt.gca(), borders=borders)
        if point_coords is not None:
            assert input_labels is not None
            show_points(point_coords, input_labels, plt.gca())
        if box_coords is not None:
            # boxes
            show_box(box_coords, plt.gca())
        if len(scores) > 1:
            plt.title(f"Mask {i+1}, Score: {score:.3f}", fontsize=18)
        plt.axis('off')
        plt.show()

image = Image.open('images/3.bmp')
image = np.array(image.convert("RGB"))

plt.figure(figsize=(10, 10))
plt.imshow(image)
plt.axis('on')
plt.show()

"""# Image Predictor with Point Prompts

"""

from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
model_cfg = "sam2_hiera_l.yaml"

sam2_model = build_sam2(model_cfg, sam2_checkpoint, device=device)

predictor = SAM2ImagePredictor(sam2_model)

predictor.set_image(image)

input_point = np.array([[1290, 1190]])
input_label = np.array([1])

plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
plt.axis('on')
plt.show()

print(predictor._features["image_embed"].shape, predictor._features["image_embed"][-1].shape)

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    multimask_output=True,
)
sorted_ind = np.argsort(scores)[::-1]
masks = masks[sorted_ind]
scores = scores[sorted_ind]
logits = logits[sorted_ind]

masks.shape  # (number_of_masks) x H x W

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label, borders=True)

"""# Image Predictor with Positive and Negative Point Prompts

"""

input_point = np.array([[1290, 1190], [1330, 1200]])
input_label = np.array([1, 0])

mask_input = logits[np.argmax(scores), :, :]  # Choose the model's best mask

masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label)

"""# Image Predictor with Bounding Box Prompt

"""

input_box = np.array([1250, 950, 1350, 1250]) #Koordinaten von Eckpunkten oben links array(0:1) und unten rechts array(2:3)

masks, scores, _ = predictor.predict(
    point_coords=None,
    point_labels=None,
    box=input_box[None, :],
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box)

"""# Image Predictor with a combination of Bounding box and point prompt"""

#Combining points and box
input_box = np.array([1250, 950, 1500, 1250])
input_point = np.array([[1360, 1210],[1380, 1210],[1380, 1000],[1360,1000]])
input_label = np.array([0,0,0,0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

image = Image.open('images/2.png')
image = np.array(image.convert("RGB"))

plt.figure(figsize=(10, 10))
plt.imshow(image)
plt.axis('on')
plt.show()

predictor.set_image(image)

print(predictor._features["image_embed"].shape, predictor._features["image_embed"][-1].shape)

input_point = np.array([[120, 200]])
input_label = np.array([1])

plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
plt.axis('on')
plt.show()

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    multimask_output=True,
)
sorted_ind = np.argsort(scores)[::-1]
masks = masks[sorted_ind]
scores = scores[sorted_ind]
logits = logits[sorted_ind]

masks.shape

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label, borders=True)





"""# Image Predictor with fine-tuned Model

"""

!wget -O sam2_hiera_small.pt "https://dl.fbaipublicfiles.com/segment_anything_2/072824/sam2_hiera_small.pt"

from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"

sam2_model = build_sam2(model_cfg, sam2_checkpoint, device=device)

predictor = SAM2ImagePredictor(sam2_model)

predictor.model.load_state_dict(torch.load("model-20img-bbox-9999epoch.torch"))

predictor.set_image(image)

input_box = np.array([1270, 950, 1500, 1250]) #Koordinaten von Eckpunkten oben links array(0:1) und unten rechts array(2:3)

plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
plt.axis('on')
plt.show()

print(predictor._features["image_embed"].shape, predictor._features["image_embed"][-1].shape)

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label, borders=True)

input_box = np.array([1250, 950, 1350, 1250]) #Koordinaten von Eckpunkten oben links array(0:1) und unten rechts array(2:3)
masks, scores, _ = predictor.predict(
    point_coords=None,
    point_labels=None,
    box=input_box[None, :],
    multimask_output=False,
)
show_masks(image, masks, scores, box_coords=input_box)

"""# Box prompt with negative point prompts on RHS

"""

def points_on_right_half(bbox, num_points=10000):
    """
    Generate points on the right half of a bounding box.

    Args:
    bbox (tuple): Bounding box coordinates as (x_min, y_min, x_max, y_max).
    num_points (int): Number of points to generate.

    Returns:
    np.ndarray: Array of points on the right half of the bounding box.
    """
    x_min, y_min, x_max, y_max = bbox

    # Find the middle of the bounding box horizontally
    x_mid = (x_min + x_max) / 2

    # Generate random x coordinates within the right half of the bounding box
    x_coords = np.random.uniform(x_mid, x_max, num_points)

    # Generate random y coordinates within the height of the bounding box
    y_coords = np.random.uniform(y_min, y_max, num_points)

    # Combine x and y coordinates into an array of points
    points = np.column_stack((x_coords, y_coords))

    return points

#Combining points and box
import numpy as np
input_box = np.array([1250, 950, 1500, 1250])
input_point = points_on_right_half(input_box, num_points=10)
input_label = np.zeros(len(input_point)) #Negative Prompts require 0 as input

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

"""# Mask Generator with Fine-tuned Model"""

image = Image.open('images/1.bmp')
image = np.array(image.convert("RGB"))

#Automatically generating object masks with SAM
#Use finetuned model by loading model into predictor, which is used by the automatic maskgenerator

from sam2.build_sam import build_sam2
from sam2.automatic_mask_generator import SAM2AutomaticMaskGenerator

sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"
# sam_kwargs = {points_per_side: Optional[int] = 32,
#         points_per_batch: int = 64,
#         pred_iou_thresh: float = 0.8,
#         stability_score_thresh: float = 0.95,
#         stability_score_offset: float = 1.0,
#         mask_threshold: float = 0.0,
#         box_nms_thresh: float = 0.7,
#         crop_n_layers: int = 0,
#         crop_nms_thresh: float = 0.7,
#         crop_overlap_ratio: float = 512 / 1500,
#         crop_n_points_downscale_factor: int = 1,
#         point_grids: Optional[List[np.ndarray]] = None,
#         min_mask_region_area: int = 0,
#         output_mode: str = "binary_mask",
#         use_m2m: bool = False,
#         multimask_output: bool = True,}
#############################################################################
# sam_kwargs = {
#     "points_per_side": 32,
#     "points_per_batch": 64,
#     "pred_iou_thresh": 0.8,
#     "stability_score_thresh": 0.95,
#     "mask_threshold":   0.0,
#     "crop_n_layers": 0,
#     "crop_n_points_downscale_factor": 21,
#     "min_mask_region_area": 0,
# } #sam_kwargs test
sam2 = build_sam2(model_cfg, sam2_checkpoint, device=device, apply_postprocessing=False) #sam kwargs test , kwargs =sam_kwargs
#_load_checkpoint(model, ckpt_path)
predictor = SAM2ImagePredictor(sam2)
predictor.model.load_state_dict(torch.load("model-20img-bbox-9999epoch.torch"))
mask_generator = SAM2AutomaticMaskGenerator(sam2)

masks = mask_generator.generate(image)

print(len(masks))
#print(masks[0].keys())

plt.figure(figsize=(20, 20))
plt.imshow(image)
show_anns(masks)
plt.axis('on')
plt.show()

"""# Bachelorarbeit - Implementierung - BASE (small)

"""

#TODO 6 Prompts - BASE - save with Annotation masks - 300dpi
#TODO Download mask scores

#1 Segment anything
#2 1 positive point
#3 Five positive Points
#4 Five positive points and five negative points
#5 1 Bounding box
#6 1 BBox and 1 positive point
#7 1 BBox and 1 negative point

!wget -O sam2_hiera_small.pt "https://dl.fbaipublicfiles.com/segment_anything_2/072824/sam2_hiera_small.pt"

#Image Predictor

np.random.seed(3)

def show_mask(mask, ax, random_color=False, borders = True):
    if random_color:
        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)
    else:
        color = np.array([30/255, 144/255, 255/255, 0.6])
    h, w = mask.shape[-2:]
    mask = mask.astype(np.uint8)
    mask_image =  mask.reshape(h, w, 1) * color.reshape(1, 1, -1)
    if borders:
        import cv2
        contours, _ = cv2.findContours(mask,cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        # Try to smooth contours
        contours = [cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours]
        mask_image = cv2.drawContours(mask_image, contours, -1, (1, 1, 1, 0.5), thickness=2)
    ax.imshow(mask_image)

def show_points(coords, labels, ax, marker_size=375):
    pos_points = coords[labels==1]
    neg_points = coords[labels==0]
    ax.scatter(pos_points[:, 0], pos_points[:, 1], color='green', marker='*', s=marker_size, edgecolor='white', linewidth=1.25)
    ax.scatter(neg_points[:, 0], neg_points[:, 1], color='red', marker='*', s=marker_size, edgecolor='white', linewidth=1.25)

def show_box(box, ax):
    x0, y0 = box[0], box[1]
    w, h = box[2] - box[0], box[3] - box[1]
    ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0, 0, 0, 0), lw=0.8))

def show_masks(image, masks, scores, point_coords=None, box_coords=None, input_labels=None, borders=True):
    for i, (mask, score) in enumerate(zip(masks, scores)):
        plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
        plt.imshow(image)
        show_mask(mask, plt.gca(), borders=borders)
        if point_coords is not None:
            assert input_labels is not None
            show_points(point_coords, input_labels, plt.gca())
        if box_coords is not None:
            # boxes
            show_box(box_coords, plt.gca())
        if len(scores) > 1:
            plt.title(f"Mask {i+1}, Score: {score:.3f}", fontsize=18)
        plt.axis('off')
        plt.show()

np.random.seed(3)

def show_anns(anns, borders=True):
    if len(anns) == 0:
        return
    sorted_anns = sorted(anns, key=(lambda x: x['area']), reverse=True)
    ax = plt.gca()
    ax.set_autoscale_on(False)

    img = np.ones((sorted_anns[0]['segmentation'].shape[0], sorted_anns[0]['segmentation'].shape[1], 4))
    img[:, :, 3] = 0
    for ann in sorted_anns:
        m = ann['segmentation']
        color_mask = np.concatenate([np.random.random(3), [0.5]])
        img[m] = color_mask
        if borders:
            import cv2
            contours, _ = cv2.findContours(m.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
            # Try to smooth contours
            contours = [cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours]
            cv2.drawContours(img, contours, -1, (0, 0, 1, 0.4), thickness=1)

    ax.imshow(img)

"""### BA Automatic  generator"""

image = Image.open('images/IMG00000000000000011063.bmp') # IMG00000000000000011063 Bimetall
#image = Image.open('images/IMG00000000000000019489.bmp') HM IMG00000000000000019489
image = np.array(image.convert("RGB"))

from sam2.build_sam import build_sam2
from sam2.automatic_mask_generator import SAM2AutomaticMaskGenerator

sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"
sam2 = build_sam2(model_cfg, sam2_checkpoint, device=device, apply_postprocessing=False)

mask_generator = SAM2AutomaticMaskGenerator(sam2)
masks = mask_generator.generate(image)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_anns(masks)
plt.axis('on')
plt.savefig('bm_base_small_auto.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_auto.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_auto.png', format='png',dpi=300)
plt.show()

"""### Point Prompt"""

from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

#sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
#model_cfg = "sam2_hiera_l.yaml"
sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"
sam2_model = build_sam2(model_cfg, sam2_checkpoint, device=device)

predictor = SAM2ImagePredictor(sam2_model)
predictor.set_image(image)

input_point = np.array([[1230, 1150]])
input_label = np.array([1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
plt.axis('on')
plt.show()

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    multimask_output=True,
)
sorted_ind = np.argsort(scores)[::-1]
masks = masks[sorted_ind]
scores = scores[sorted_ind]
logits = logits[sorted_ind]

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label, borders=True)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
show_mask(masks[0],plt.gca())
plt.axis('on')
plt.savefig('bm_base_small_1pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_1pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_1pointprompt.png', format='png',dpi=300)
plt.show()

"""### 5 Positive Point Prompts and 5 negative prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('on')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
#show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('on')
plt.savefig('bm_base_small_10pointprompt_withoutprompts.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_10pointprompt_withoutprompts.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_10pointprompt_withoutprompts.png', format='png',dpi=300)
plt.show()



"""### 5 Positive Point Prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070]])
input_label = np.array([1,1,1,1,1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('on')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('on')
plt.savefig('bm_base_small_5pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_5pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_5pointprompt.png', format='png',dpi=300)
plt.show()

"""### Bounding Box"""

input_box = np.array([1210, 1050, 1300, 1230]) #Koordinaten von Eckpunkten oben links array(0:1) und unten rechts array(2:3) [1230, 1150]

masks, scores, _ = predictor.predict(
    point_coords=None,
    point_labels=None,
    box=input_box[None, :],
    multimask_output=False,
)
show_masks(image, masks, scores, box_coords=input_box)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_bbox.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_bbox.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_bbox.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with positive point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150]])
input_label = np.array([1])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_bbox_1pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_bbox_1pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_bbox_1pos.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with negative point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1280, 1180]])
input_label = np.array([0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_bbox_1neg.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_bbox_1neg.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_bbox_1neg.png', format='png',dpi=300)
plt.show()



"""### Bounding Box with 5 negative point prompts & 5 positive point prompts

"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=5)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_bbox_5neg5pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_bbox_5neg5pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_bbox_5neg5pos.png', format='png',dpi=300)
plt.show()

"""# Bachelorarbeit - Implementierung - BASE(Large)

"""

#TODO 6 Prompts - BASE - save with Annotation masks - 300dpi
#TODO Download mask scores

#1 Segment anything
#2 1 positive point
#3 Five positive Points
#4 Five positive points and five negative points
#5 1 Bounding box
#6 1 BBox and 1 positive point

"""### BA Automatic  generator"""

image = Image.open('images/IMG00000000000000011063.bmp') # IMG00000000000000011063 Bimetall
#image = Image.open('images/IMG00000000000000019489.bmp') HM IMG00000000000000019489
image = np.array(image.convert("RGB"))

from sam2.build_sam import build_sam2
from sam2.automatic_mask_generator import SAM2AutomaticMaskGenerator

sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
model_cfg = "sam2_hiera_l.yaml"
sam2 = build_sam2(model_cfg, sam2_checkpoint, device=device, apply_postprocessing=False)

mask_generator = SAM2AutomaticMaskGenerator(sam2)
masks = mask_generator.generate(image)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_anns(masks)
plt.axis('off')
plt.savefig('bm_base_large_auto.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_auto.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_auto.png', format='png',dpi=300)
plt.show()

"""### Point Prompt"""

from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
model_cfg = "sam2_hiera_l.yaml"
sam2_model = build_sam2(model_cfg, sam2_checkpoint, device=device)

predictor = SAM2ImagePredictor(sam2_model)
predictor.set_image(image)

input_point = np.array([[1230, 1150]])
input_label = np.array([1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
plt.axis('off')
plt.show()

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    multimask_output=True,
)
sorted_ind = np.argsort(scores)[::-1]
masks = masks[sorted_ind]
scores = scores[sorted_ind]
logits = logits[sorted_ind]

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label, borders=True)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_large_1pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_1pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_1pointprompt.png', format='png',dpi=300)
plt.show()

"""### 5 Positive Point Prompts and 5 negative prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('on')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
#show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_large_10pointprompt_withoutprompts.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_10pointprompt_withoutprompts.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_10pointprompt_withoutprompts.png', format='png',dpi=300)
plt.show()



"""### 5 Positive Point Prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070]])
input_label = np.array([1,1,1,1,1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('off')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_large_5pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_5pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_5pointprompt.png', format='png',dpi=300)
plt.show()

"""### Bounding Box"""

input_box = np.array([1210, 1050, 1300, 1230]) #Koordinaten von Eckpunkten oben links array(0:1) und unten rechts array(2:3) [1230, 1150]

masks, scores, _ = predictor.predict(
    point_coords=None,
    point_labels=None,
    box=input_box[None, :],
    multimask_output=False,
)
show_masks(image, masks, scores, box_coords=input_box)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_large_bbox.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_bbox.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_bbox.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with positive point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150]])
input_label = np.array([1])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_large_bbox_1pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_bbox_1pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_bbox_1pos.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with negative point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1280, 1180]])
input_label = np.array([0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_large_bbox_1neg.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_bbox_1neg.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_bbox_1neg.png', format='png',dpi=300)
plt.show()



"""### Bounding Box with 5 negative point prompts & 5 positive point prompts

"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=5)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_large_bbox_5neg5pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_large_bbox_5neg5pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_large_bbox_5neg5pos.png', format='png',dpi=300)
plt.show()

"""# Bachelorarbeit - Implementierung - Finetuned model-bbox-20img-100epoch

"""

#TODO 6 Prompts - Finetuned - save with Annotation masks - 300dpi
#TODO Download mask scores

#1 Segment anything
#2 1 positive point
#3 Five positive Points
#4 Five positive points and five negative points
#5 1 Bounding box
#6 1 BBox and 1 positive point

!wget -O sam2_hiera_small.pt "https://dl.fbaipublicfiles.com/segment_anything_2/072824/sam2_hiera_small.pt"

#Image Predictor

np.random.seed(3)

def show_mask(mask, ax, random_color=False, borders = True):
    if random_color:
        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)
    else:
        color = np.array([30/255, 144/255, 255/255, 0.6])
    h, w = mask.shape[-2:]
    mask = mask.astype(np.uint8)
    mask_image =  mask.reshape(h, w, 1) * color.reshape(1, 1, -1)
    if borders:
        import cv2
        contours, _ = cv2.findContours(mask,cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        # Try to smooth contours
        contours = [cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours]
        mask_image = cv2.drawContours(mask_image, contours, -1, (1, 1, 1, 0.5), thickness=2)
    ax.imshow(mask_image)

def show_points(coords, labels, ax, marker_size=375):
    pos_points = coords[labels==1]
    neg_points = coords[labels==0]
    ax.scatter(pos_points[:, 0], pos_points[:, 1], color='green', marker='*', s=marker_size, edgecolor='white', linewidth=1.25)
    ax.scatter(neg_points[:, 0], neg_points[:, 1], color='red', marker='*', s=marker_size, edgecolor='white', linewidth=1.25)

def show_box(box, ax):
    x0, y0 = box[0], box[1]
    w, h = box[2] - box[0], box[3] - box[1]
    ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0, 0, 0, 0), lw=0.8))

def show_masks(image, masks, scores, point_coords=None, box_coords=None, input_labels=None, borders=True):
    for i, (mask, score) in enumerate(zip(masks, scores)):
        plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
        plt.imshow(image)
        show_mask(mask, plt.gca(), borders=borders)
        if point_coords is not None:
            assert input_labels is not None
            show_points(point_coords, input_labels, plt.gca())
        if box_coords is not None:
            # boxes
            show_box(box_coords, plt.gca())
        if len(scores) > 1:
            plt.title(f"Mask {i+1}, Score: {score:.3f}", fontsize=18)
        plt.axis('off')
        plt.show()

np.random.seed(3)

def show_anns(anns, borders=True):
    if len(anns) == 0:
        return
    sorted_anns = sorted(anns, key=(lambda x: x['area']), reverse=True)
    ax = plt.gca()
    ax.set_autoscale_on(False)

    img = np.ones((sorted_anns[0]['segmentation'].shape[0], sorted_anns[0]['segmentation'].shape[1], 4))
    img[:, :, 3] = 0
    for ann in sorted_anns:
        m = ann['segmentation']
        color_mask = np.concatenate([np.random.random(3), [0.5]])
        img[m] = color_mask
        if borders:
            import cv2
            contours, _ = cv2.findContours(m.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
            # Try to smooth contours
            contours = [cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours]
            cv2.drawContours(img, contours, -1, (0, 0, 1, 0.4), thickness=1)

    ax.imshow(img)

"""### BA Automatic  generator"""

image = Image.open('images/IMG00000000000000011063.bmp') # IMG00000000000000011063 Bimetall
#image = Image.open('images/IMG00000000000000019489.bmp') HM IMG00000000000000019489
image = np.array(image.convert("RGB"))

from sam2.build_sam import build_sam2
from sam2.automatic_mask_generator import SAM2AutomaticMaskGenerator

sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"
sam2 = build_sam2(model_cfg, sam2_checkpoint, device=device, apply_postprocessing=False)


#_load_checkpoint(model, ckpt_path)
predictor = SAM2ImagePredictor(sam2)
predictor.model.load_state_dict(torch.load("model-small-10000.torch"))


mask_generator = SAM2AutomaticMaskGenerator(sam2)
masks = mask_generator.generate(image)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_anns(masks)
plt.axis('off')
plt.savefig('bm_base_small_finetuned_auto.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_auto.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_auto.png', format='png',dpi=300)
plt.show()

"""### Point Prompt"""

from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

#sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
#model_cfg = "sam2_hiera_l.yaml"
sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"
sam2_model = build_sam2(model_cfg, sam2_checkpoint, device=device)

predictor = SAM2ImagePredictor(sam2_model)
predictor.set_image(image)
predictor.model.load_state_dict(torch.load("model-small-10000.torch"))

input_point = np.array([[1230, 1150]])
input_label = np.array([1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
plt.axis('on')
plt.show()

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    multimask_output=True,
)
sorted_ind = np.argsort(scores)[::-1]
masks = masks[sorted_ind]
scores = scores[sorted_ind]
logits = logits[sorted_ind]

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label, borders=True)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned_1pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_1pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_1pointprompt.png', format='png',dpi=300)
plt.show()

"""### 5 Positive Point Prompts and 5 negative prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('on')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
#show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned_10pointprompt_withoutprompts.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_10pointprompt_withoutprompts.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_10pointprompt_withoutprompts.png', format='png',dpi=300)
plt.show()



"""### 5 Positive Point Prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070]])
input_label = np.array([1,1,1,1,1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('on')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned_5pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_5pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_5pointprompt.png', format='png',dpi=300)
plt.show()

"""### Bounding Box"""

input_box = np.array([1210, 1050, 1300, 1230]) #Koordinaten von Eckpunkten oben links array(0:1) und unten rechts array(2:3) [1230, 1150]

masks, scores, _ = predictor.predict(
    point_coords=None,
    point_labels=None,
    box=input_box[None, :],
    multimask_output=False,
)
show_masks(image, masks, scores, box_coords=input_box)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned_bbox.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_bbox.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_bbox.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with positive point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150]])
input_label = np.array([1])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned_bbox_1pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_bbox_1pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_bbox_1pos.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with negative point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1280, 1180]])
input_label = np.array([0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned_bbox_1neg.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_bbox_1neg.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_bbox_1neg.png', format='png',dpi=300)
plt.show()



"""### Bounding Box with 5 negative point prompts & 5 positive point prompts

"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=5)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned_bbox_5neg5pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned_bbox_5neg5pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned_bbox_5neg5pos.png', format='png',dpi=300)
plt.show()



"""# Bachelorarbeit - Implementierung - Finetuned model-500img-bbox-6851epoch

"""

#TODO 6 Prompts - Finetuned - save with Annotation masks - 300dpi
#TODO Download mask scores

#1 Segment anything
#2 1 positive point
#3 Five positive Points
#4 Five positive points and five negative points
#5 1 Bounding box
#6 1 BBox and 1 positive point

#!wget -O sam2_hiera_small.pt "https://dl.fbaipublicfiles.com/segment_anything_2/072824/sam2_hiera_small.pt"

"""### BA Automatic  generator"""

image = Image.open('images/IMG00000000000000011063.bmp') # IMG00000000000000011063 Bimetall
#image = Image.open('images/IMG00000000000000019489.bmp') HM IMG00000000000000019489
image = np.array(image.convert("RGB"))

from sam2.build_sam import build_sam2
from sam2.automatic_mask_generator import SAM2AutomaticMaskGenerator

sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"
sam2 = build_sam2(model_cfg, sam2_checkpoint, device=device, apply_postprocessing=False)


#_load_checkpoint(model, ckpt_path)
predictor = SAM2ImagePredictor(sam2)
predictor.model.load_state_dict(torch.load("model-500img-bbox-6851epoch.torch"))


mask_generator = SAM2AutomaticMaskGenerator(sam2)
masks = mask_generator.generate(image)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_anns(masks)
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_auto.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_auto.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_auto.png', format='png',dpi=300)
plt.show()

"""### Point Prompt"""

from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

#sam2_checkpoint = "../checkpoints/sam2_hiera_large.pt"
#model_cfg = "sam2_hiera_l.yaml"
sam2_checkpoint = "sam2_hiera_small.pt"
model_cfg = "sam2_hiera_s.yaml"
sam2_model = build_sam2(model_cfg, sam2_checkpoint, device=device)

predictor = SAM2ImagePredictor(sam2_model)
predictor.set_image(image)
predictor.model.load_state_dict(torch.load("model-500img-bbox-6851epoch.torch"))

input_point = np.array([[1230, 1150]])
input_label = np.array([1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
plt.axis('on')
plt.show()

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    multimask_output=True,
)
sorted_ind = np.argsort(scores)[::-1]
masks = masks[sorted_ind]
scores = scores[sorted_ind]
logits = logits[sorted_ind]

show_masks(image, masks, scores, point_coords=input_point, input_labels=input_label, borders=True)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca())
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_1pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_1pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_1pointprompt.png', format='png',dpi=300)
plt.show()

"""### 5 Positive Point Prompts and 5 negative prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('on')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
#show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_10pointprompt_withoutprompts.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_10pointprompt_withoutprompts.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_10pointprompt_withoutprompts.png', format='png',dpi=300)
plt.show()



"""### 5 Positive Point Prompts"""

input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070]])
input_label = np.array([1,1,1,1,1])
plt.figure(figsize=(10, 10))
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
plt.axis('on')
plt.show()

mask_input = logits[np.argmax(scores), :, :]
masks, scores, _ = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    mask_input=mask_input[None, :, :],
    multimask_output=False,
)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_5pointprompt.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_5pointprompt.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_5pointprompt.png', format='png',dpi=300)
plt.show()

"""### Bounding Box"""

input_box = np.array([1210, 1050, 1300, 1230]) #Koordinaten von Eckpunkten oben links array(0:1) und unten rechts array(2:3) [1230, 1150]

masks, scores, _ = predictor.predict(
    point_coords=None,
    point_labels=None,
    box=input_box[None, :],
    multimask_output=False,
)
show_masks(image, masks, scores, box_coords=input_box)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with positive point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150]])
input_label = np.array([1])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_1pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_1pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_1pos.png', format='png',dpi=300)
plt.show()

"""### Bounding Box with negative point prompt"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1280, 1180]])
input_label = np.array([0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=75)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_1neg.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_1neg.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_1neg.png', format='png',dpi=300)
plt.show()



"""### Bounding Box with 5 negative point prompts & 5 positive point prompts

"""

#Combining points and box
input_box = np.array([1210, 1050, 1300, 1230])
input_point = np.array([[1230, 1150],[1230, 1110],[1230, 1170],[1270, 1100],[1270, 1070],
                        [1280, 1150],[1280, 1160],[1280, 1140],[1270, 1180],[1290, 1180]],)
input_label = np.array([1,1,1,1,1,0,0,0,0,0])

masks, scores, logits = predictor.predict(
    point_coords=input_point,
    point_labels=input_label,
    box=input_box,
    multimask_output=False,
)

show_masks(image, masks, scores, box_coords=input_box, point_coords=input_point, input_labels=input_label)

plt.figure(figsize = (2464 / 300, 2056 / 300), dpi=300)
plt.imshow(image)
show_points(input_point, input_label, plt.gca(),marker_size=5)
show_mask(masks[0],plt.gca())
show_box(input_box, plt.gca())
plt.axis('off')
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_5neg5pos.pdf', format='pdf',dpi=300)
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_5neg5pos.eps', format='eps',dpi=300) #name convention "metal_prompt_model"
plt.savefig('bm_base_small_finetuned500img-bbox-6851epoch_bbox_5neg5pos.png', format='png',dpi=300)
plt.show()